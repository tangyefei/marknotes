<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>
<body>

  <script>
  //  /**
  //   * @param {number} n
  //   * @return {string[][]}
  //   */
  //   var solveNQueens = function(n) {
  //     // speed > 5.05% memory < 100%

  //     var result =[];

  //     function createBoard(w, basedOn) {
  //       var board = new Array(w);
  //       for (let i = 0; i < board.length; i++) {
  //         let rowCells = board[i] = new Array(w);
  //         if(basedOn) {
  //           for (let j = 0; j < rowCells.length; j++) {
  //             rowCells[j] = basedOn[i][j];
  //           }
  //         }
  //       }
  //       return board;
  //     }

  //     function findAvCells(board){
  //       let cells = [];
  //       for (let i = board.length - 1; i >= 0 ; i--) {
  //         for (let j = board[i].length - 1; j >= 0; j--) {
  //           if(board[i][j] === undefined) {
  //             cells.push({x: i, y: j})
  //           }
  //         }
  //       }
  //       return cells;
  //     }

  //     function placeQueueWithNewBoard(board,avCells,cell){
  //       var newBoard = createBoard(board.length, board);
  //       var newAvCells = [];
  //       avCells.forEach(d => {
  //         if(isConflict(d, cell)) {
  //           newBoard[d.x][d.y] = false;
  //         } else {
  //           newAvCells.push(d);
  //         }
  //       })
  //       newBoard[cell.x][cell.y] = true;
  //       return {newBoard, newAvCells};
  //     }

  //     function isConflict(a, b) {
  //       return (a.x == b.x || a.y == b.y || Math.abs(a.x-b.x) == Math.abs(a.y-b.y))  
  //     }
      
  //     function findNQueue(board, nth, inheritAvCells) {
  //       if(nth === n) {
  //          result.push(board);
  //          return;
  //       }
  //       if(inheritAvCells && inheritAvCells.length == 0) {
  //         return;
  //       }
  //       var avCells = inheritAvCells || findAvCells(board);

  //       for (var i = avCells.length - 1; i >= 0; i--) {
  //         var avCell = avCells.splice(i, 1)[0];
  //         var {newAvCells, newBoard} = placeQueueWithNewBoard(board, avCells, avCell);

  //         findNQueue(newBoard, nth + 1, newAvCells);

  //         board[avCell.x][avCell.y] = false; // prevent duplicate
  //       }
  //     } 

  //     findNQueue(createBoard(n), 0);

  //     return result.map(d => {
  //       return d.map(dd => {
  //         return dd.map(ddd => {
  //           return ddd ? 'Q':'.'
  //         }).join('')
  //       })
  //     });
  //   }

    /**
 * @param {number} n
 * @return {string[][]}
 */
var solveNQueens = function(n) {
      var result =[];
      function createBoard(w, basedOn) {
        var board = new Array(w);
        for (let i = 0; i < board.length; i++) {
          let rowCells = board[i] = new Array(w);
          if(basedOn) {
            for (let j = 0; j < rowCells.length; j++) {
              rowCells[j] = basedOn[i][j];
            }
          }
        }
        return board;
      }
      function findAvCells(board){
        let cells = [];
        for (let i = 0; i < board.length; i++) {
          for (let j = 0; j < board[i].length; j++) {
            if(board[i][j] === undefined) {
              cells.push({x: i, y: j})
            }
          }
        }
        return cells;
      }
      function placeQueueWithNewBoard(board,avCells,cell){
        var newBoard = createBoard(board.length, board);
        avCells.forEach(d => {
          if(isConflict(d, cell)) {
            newBoard[d.x][d.y] = false;
          }
        })
        newBoard[cell.x][cell.y] = true;
        return newBoard;
      }
      function isConflict(a, b) {
        return (a.x == b.x || a.y == b.y || Math.abs(a.x-b.x) == Math.abs(a.y-b.y))  
      }
      function findNQueue(board, nth) {
        if(nth === n) {
           result.push(board);
           return;
        }
        var avCells = findAvCells(board);

        if(avCells.length == 0) return;

        for (var i = 0; i < avCells.length; i++) {
          var newBoard = placeQueueWithNewBoard(board, avCells, avCells[i]);
          if(newBoard) {
            findNQueue(newBoard, nth + 1);
            // prevent duplicate
            board[avCells[i].x][avCells[i].y] = false;
          }
        }
      } 
      findNQueue(createBoard(n), 0);

      return result.map(d => {
        return d.map(dd => {
          return dd.map(ddd => {
            return ddd ? 'Q':'.'
          }).join('')
        })
      });
};


    var start = (new Date()).getTime();
    console.log(solveNQueens(10));
    var end = (new Date()).getTime();
    console.log((end - start)/1000);
    // console.log(JSON.stringify(solveNQueens(4))=='[[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]');
  </script>
  
</body>
</html>