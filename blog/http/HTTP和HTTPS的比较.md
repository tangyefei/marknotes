# HTTP vs HTTPS


## 1. 协议发展历史

参考 [阮一峰：HTTP协议入门](http://www.ruanyifeng.com/blog/2016/08/http.html)，介绍了版本0.9、1.0、1.1、SPDY、HTTP/2的发展和演变历史。

### HTTP 0.9

发布于1991年，只有一个GET命令，只能返回HTML格式的字符串。

### HTTP 1.0

1996年发布，内容大大增加：

- 任何格式的内容都可以发送。
- 除了GET命令，还引入了POST命令和HEAD命令。
- HTTP请求和回应除了数据部分，每次通信都必须包括头信息（HTTP header）。
- 其他还包括状态码、多字符集支持、多部分发送、权限、缓存、内容编码等。


它主要缺点是，每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。

为了解决这个问题，有些浏览器在请求时，用了一个非标准的Connection字段。

```
Connection: keep-alive
```

这个字段要求服务器不要关闭TCP连接，以便其他请求复用。服务器同样回应这个字段。

### HTTP 1.1

1997年发布，进一步完善了 HTTP 协议，直到现在（2016年8月）还是最流行的版本。

#### 1. 持久连接

TCP连接默认不关闭，可以被多个请求复用，不用声明`Connection: keep-alive`。

客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。

规范的做法是，客户端在最后一个请求时，发送`Connection: close`，明确要求服务器关闭TCP连接。

目前，对于同一个域名，大多数浏览器允许同时建立6个持久连接。

#### 2. 管道机制

在同一个TCP连接里面，可以同时发送请求，而不用先发送一个，等到成功后再发送另一个。但服务器的响应还是按照顺序，回应有先有后。

#### 3. Content-Length字段

Content-length字段的作用，声明本次回应的数据长度。

```
Content-Length: 3495
```

**上面代码告诉浏览器，本次回应的长度是3495个字节，后面的字节就属于下一个回应了。**

#### 4. 分块传输编码

可以不使用Content-Length字段，而使用"分块传输编码"（chunked transfer encoding）。

只要请求或回应的头信息有Transfer-Encoding字段，就表明回应将由数量未定的数据块组成。

```
Transfer-Encoding: chunked
```

**每个非空的数据块之前，会有一个16进制的数值，表示这个块的长度。最后是一个大小为0的块，就表示本次回应的数据发送完了。下面是一个例子。**


```
HTTP/1.1 200 OK
Content-Type: text/plain
Transfer-Encoding: chunked

25
This is the data in the first chunk

1C
and this is the second one

3
con

8
sequence

0
```

#### 5. 其他功能

提供了新的方法：PUT、PATCH、HEAD、 OPTIONS、DELETE。

客户端请求的头信息新增了Host字段，用来指定服务器的域名。**Host字段，就可以将请求发往同一台服务器上的不同网站，为虚拟主机的兴起打下了基础。**

```
Host: www.example.com
```

#### 6. 缺点

**虽然1.1版允许复用TCP连接**，但是同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为"队头堵塞"（Head-of-line blocking）。

为了避免这个问题，只有两种方法：一是减少请求数，二是同时多开持久连接。

**域名分片（domain sharding）是属于哪一类优化技巧？**

### SPDY 协议

2009年，谷歌公开了自行研发的 SPDY 协议，主要解决 HTTP/1.1 效率不高的问题。这个协议在Chrome浏览器上证明可行以后，就被当作 HTTP/2 的基础，主要特性都在 HTTP/2 之中得到继承。

### HTTP/2

2015年发布，它不叫 HTTP/2.0，是因为标准委员会不打算再发布子版本了，下一个新版本将是 HTTP/3。

#### 1. 二进制协议

HTTP/1.1 版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为"帧"（frame）：头信息帧和数据帧。

#### 2. 多工
HTTP/2 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了"队头堵塞"。

举例来说，在一个TCP连接里面，服务器同时收到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分。

这样双向的、实时的通信，就叫做多工（Multiplexing）。

#### 3. 数据流
因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。

HTTP/2 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。

数据流发送到一半的时候，客户端和服务器都可以发送信号（RST_STREAM帧），取消这个数据流。1.1版取消数据流的唯一方法，就是关闭TCP连接。这就是说，HTTP/2 可以取消某一次请求，同时保证TCP连接还打开着，可以被其他请求使用。

客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。

#### 4. 头信息压缩
HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如Cookie和User Agent，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。

HTTP/2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用gzip或compress压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。

#### 5. 服务器推送

HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。

常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。


除了加粗部分，此处为整理的**若干有疑问的地方：三次握手，head请求，Keep-alive**

## HTTP/2实践

？？


## HTTPS

### SSL/TLS协议简述

参考  [SSL/TLS协议运行机制的概述](http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html)



#### 作用

（1） 所有信息都是**加密传播**，第三方无法窃听。

（2） 具有**校验机制**，一旦被篡改，通信双方会立刻发现。

（3） 配备身份证书，**防止身份被冒充**。

#### 历史

|版本|时间|状态|
|---|---|---|
|SSL 1.0|1994|未发布|
|SSL 2.0|1995|有严重漏洞|
|SSL 3.0|1996|大规模应用|
|TLS 1.0|1999|应用最广泛|
|TLS 1.1/1.2|2006/2008|主流浏览器都支持|

#### 运行过程

首先要熟悉两个概念，公钥加密法 和 数字证书。

"公钥加密法" 是客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。

"数字证书" 就是互联网通讯中标志通讯各方身份信息的一串数字，是身份认证机构盖在数字身份证上的一个章或印（或者说加在数字身份证上的一个签名）。它是由权威机构——CA机构中心发行的，人们可以在网上用它来识别对方的身份。

SSL/TLS协议的基本思路是采用公钥加密法，其中公钥放在数字证书，另外存在的一个问题是，使用公钥加密计算量太大，为了解决这个问题：


> 每一次对话（session），客户端和服务器端都生成一个"对话密钥"（session key），用它来加密信息。由于"对话密钥"是对称加密，所以运算速度非常快，而服务器公钥只用于加密"对话密钥"本身，这样就减少了加密运算的消耗时间。

#### 握手阶段的详细过程

握手阶段即 客户端向服务器端索要并验证公钥 +  双方协商生成"对话密钥" 的过程。

作者的另外一篇文章 [图解SSL/TLS协议](http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html) 可以辅助理解握手过程，至于算法深入暂且不究。

![http://www.ruanyifeng.com/blogimg/asset/2014/bg2014092002.png](http://www.ruanyifeng.com/blogimg/asset/2014/bg2014092002.png)

