# 17 HTTP的连接管理


## 长连接 vs 短连接

HTTP协议在0.9/1.0时期，每次收到响应报文后会立即关闭连接，它的缺点在于浪费严重。

参考第8节，一个请求-响应过程需要4个数据包，而握手和挥手分别要用3个和四个数据包，传输效率会很低。

长连接自然也有握手和挥手的损耗，但是平摊在了发送的多个请求身上。

![长连接 vs 短连接](https://blog-1258030304.cos.ap-guangzhou.myqcloud.com/books/master-http/short-vs-long-connecton.jpeg)

## 连接相关的字段

在HTTP/1.1中会默认启用长连接，当然也可以在请求头明确的要求：`Connection: keep-alive`。

服务端不管客户端是否显示要求，只要服务端支持，它就会在响应报文中放置 `Connection: keep-alive`。


长连接也需要在恰当的时间关闭，下面是一些关闭的策略：

- 客户端通过在请求头部加上 `Connection:close` 字段，告诉服务器这次通信后就关闭，服务端看到后，在响应也会加上这个字段
- 服务端通常不会主动关闭连接，但可以使用一些策略，比如Nginx使用keepalive_timeout和keepalive_requests表示最长无请求时间和最大请求数
- 客户端可以在秦秋报文添加通用头部字段 `Keep-Alive: timeout= value`不过约束力不强，通信方通常都不会遵守

### 实践

在实验环境中 [http://www.chrono.com/17-1](http://www.chrono.com/17-1) 被设置为 keepalive_timeout 为60秒，keepalive_requests最多发送5个请求，可以实际操作看看。

## 堵头阻塞

堵头阻塞是长连接还是短连接没关系，因为报文发送是一个先进先出的串行队列，只要前面的请求处理太慢，后面的请求也会被阻塞。

思考：平时很难感受到所谓的阻塞过程，如何论证这一点呢？

## 性能优化

只要还是使用HTTP/1.1，请求应答模型没有结束，上述问题就无法解决，只能缓解。

### 并发连接

通过对一个域名发起多个长连接，成为”并发连接“，客户端虽然建议并发，但不能”滥用“，RFC限制组多并发2个连接，众多浏览器无视标准，直接提高到了6-8个，RFC也就顺手推重，取消了2个的限制。

### 域名分片

请求非常多的时候，多个并发还是慢，这个时候可以考虑多开几个域名，但是每个域名都指向同一台服务器，这就是”域名分片“。

## 课外

- 利用HTTP长连接特性对服务器发起大量请求，导致服务器资源耗尽，最终导致”拒绝服务“，这就是常说的DDos。
- pipliine是HTTP连接的第三种方式，但是因为存在问题，事实上被废弃了。
- Connection:Upgrade配合状态码101，表示协议升级，比如从HTTP切换到Websocket。



