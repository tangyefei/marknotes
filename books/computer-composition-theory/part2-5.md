## #5 计算机指令：让我们试试用纸带编程


早期的计算机程序要用打孔卡，因为它们还没有能力理解像C和Python这样的高级语言。

到今天，我们的计算机，其实处理的仍然是所谓的“机器码”，也就是一连串的“0”和“1”的数字。

#### 1. CPU帮我们做了什么

CPU全称是Central Processing Unit,中文是中央处理器。硬件角度看它是一个超大规模集成电路，软件角度看它是一个执行各种计算机指令的逻辑机器。

这里的计算机指令，好比是CPU能听懂的语言，我们也可以把它称为机器语言。

不同的CPU能听懂的语言不一样，他们所各自支持的语言叫做计算机指令集（Instruction Set）。

一个计算机程序，由成千上万跳指令组成，但是CPU中不能存放着所有指令，它们是存放在存储器中的，这种把指令存储在存储器里的计算机就叫做存储程序性计算机（Stored-program Computer）。

当然，在现代计算机以前，也有“插线板计算机”（Plugboard Computer），感兴趣可以了解。

#### 2. 代码怎么变成机器码

如下是一段C语言的代码：

```
int main {
	int a = 1;
	int b = 2;
	a = a + b;
}
```

要把上述的程序在Linux操作系统中跑起来，需要做的步骤有

1. 把程序翻译成汇编语言的程序，这个过程叫编译（Compile）
2. 用汇编器翻译成机器代码

机器码由0和1组成，一条条的机器码，就是一条条的计算机指令。

为什么不一步到位，将程序直接翻译成机器码呢？因为编译程序对程序员友好，方便与基于它做一些工作。

在Linux中可以使用gcc和objdump命令吧汇编代码 和 机器代码都输出来。

![插图](https://blog-1258030304.cos.ap-guangzhou.myqcloud.com/WechatIMG1039.png)

#### 3. 解析指令和机器码

常见的指令分为五类，简单表示可以参考下图：

![插图](https://blog-1258030304.cos.ap-guangzhou.myqcloud.com/WechatIMG1037.jpeg)

为了快速理解机器码的计算方式，选用MIPS指令集来看看机器码是如何生成的。


我们以 `add $t0, $s2, $s1` 为例，在MIPS指令中，opcode是0，rs代表第一个寄存器s1的底子，rt代表第二个寄存器s2的地址，rd代表临时寄存器t0的底子，这些数字拼接在一起就变成了一个MIPS的加法指令。

![插图](https://blog-1258030304.cos.ap-guangzhou.myqcloud.com/WechatIMG1038.jpeg)

如果用打孔带，1代表打孔，0代表没打孔，4行8列的命令（8位16进制），那么这条命令大概长这样：

![插图](https://blog-1258030304.cos.ap-guangzhou.myqcloud.com/WechatIMG1036.png)











