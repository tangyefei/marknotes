# JavaScript权威指南-第6版

# 第一部分

# 第3章 类型、值和变量

## 3.1 数字

### 整型直接量

用数字序列表示一个十进制正式，也可以使用 `0x` 或者 `0X` 表示一个十六进制，ECMAscript标准不支持八进制直接量，但在某些实现中支持，它以`0`开始。

### 浮点型直接量

浮点数可以使用 `[整数部分][小数点][小数部分]` 组成，也可以使用浮点技术法表示  `[实数][e|E][+|-][整数]` 表示，例如

```
6.02e23 // 6. 02 × 1023
```

### JavaScript中的算术运算

除了加减乘除求余之外，通过Math对象的属性可以获得更复杂运算的能力。

比较特殊的介绍在 overflow、underflow、被零整除时候的情况

#### overflow

数字超过能表示的最大边界，会用 Infinity 表示，负数则用 - Infinity表示。基于它的加减乘除运算还是一样的结果。

#### underflow

运算结果无限接近于零并且比JavaScript所能表示的最小的值还小时，JavaScript会返回0，当数字为负数的时候为-0。0和-0除了用在除法中，几乎完全一样（0===-0。

#### 被零整除

在JavaScript中被零整除不会报错，它只是简单地返回无穷大（Inifinity）或者（-Infinity）。

特殊的零除以零是没有意义的，返回NaN。NaN比较特殊，和任何值都不相等（包括自身），需要使用isNaN来判断（实现方式为x!=x)



### 二进制浮点数和四舍五入错误

JavaScript能表示的浮点数个数是有限的，因为它采用的是二进制表示法，可以精确表示1/2 1/4 1/8，常用的1/10却无法精确表示。结果就是一些计算结果不符合预期：

```
var x = .3 - .2; // 30 美分 减去 20 美分 
var y = .2 - .1; // 20 美分 减去 10 美分 
x == y // => false: 两 值 不相等! 
x == .1 // => false: .3-. 2 不等于 .1 
y == .1 // => true: .2-. 1 等于 .1
```

因此你可能更愿意使用整数“分” 而不是小数“元”来进行计算。

### 日期和时间

这里提供了一个日期计算的简单教程

```
var then = new Date( 2011, 0, 1); // 2011 年 1 月 1 日 
var later = new Date( 2011, 0, 1, 17, 10, 30);// 同一 天, 当地时间 5: 10: 30pm, 
var now = new Date(); // 当前 日期 和 时间 
var elapsed = now - then; // 日期 减法： 计算 时间 间隔 的 毫秒 数 
later. getFullYear() // => 2011 
later. getMonth() // => 0: 从 0 开始 计数 的 月份 
later. getDate() // => 1: 从 1 开始 计数 的 天数 
later. getDay() // => 5: 得到 星期 几， 0 代表 星期日， 5 代表 星期一 
later. getHours() // => 当地时间 17: 5pm 
later. getUTCHours() // 使用 UTC 表示 小时 的 时间， 基于 时区
```

## 3.2 文本

字符串由一组由16位（2字节）值组成的不可变的有序序列，字符串长度为所含16位值的个数。

JavaScript用UTF-16编码的Unicode字符集，常用字符用16位内码表示，不能表示为16位的字符则用两个16位值组成的序列表示，这意味着一个字符从长度成为了2。

注：在阮一峰的文章中，说到JavaScript是用UCS-2进行编码的，而UTC-16是UCS-2的超集。语言到底是用的什么标准？

JavaScript中的字符方法是基于16位值，而非字符；在ES6中增加了一些方法(String.getCodePointAt等) 和 遍历属性（for...of)。

### 字符串直接量

ES3中字符必须写在同一行，ES5中可以使用`\`将字符拆成若干行书写(实际展示还是紧凑的字符)，希望字符串直接另起一行可以使用 `\n`。字符用单双引号括起来，和字符串内部引号冲突时，可以使用`\`转译。

### 转译字符

使用反斜杠可以使我们避免使用常规方式来解释一些字符。


![转译表](./converter.png)


一个通用规则是，使用 `\x` 表示Latin-1中的字符，使用`\u`表示Unicode中的字符 

```
"\xA9" //©
"\u03C0" //π
```


### 字符串的使用

字符串是不可变的，很多操作字符串的方法都是返回的新字符串。

可以使用 `+` 来拼接字符串，可以使用`.length`来获取字符串长度，还有很多可供调用方法：

```

var s = "hello, world" // 定义 一个 字符串 
s. charAt( 0) // => "h": 第一个 字符 
s. charAt( 
s. length- 1) // => "d": 最后 一个 字符 
s. substring( 1, 4) // => "ell": 第 2~ 4 个 字符 
s. slice( 1, 4) // => "ell": 同上 
s. slice(- 3) // => "rld": 最后 三个 字符 
s. indexOf(" l") // => 2: 字符 l 首次 出现 的 位置 
s. lastIndexOf(" l") // => 10: 字符 l 最后 一次 出现 的 位置 
s. indexOf(" l", 3) // => 3: 在 位置 3 及之 后 首次 出现 字符 l 的 位置 
s. split(", ") // => ["hello", "world"] 分割 成 子串 
s. replace(" h", "H") // => "Hello, world": 全文 字符 替换 
s. toUpperCase() // => "HELLO, WORLD"

```

### 模式匹配

JavaScript定义了RegExp这个文本匹配对象，在String和RegExp中都定义了一些用于匹配的函数。

```

var text = "testing: 1, 2, 3"; // 文本 示例 
var pattern = /\d+/ g // 匹配 所有 包含 一个 或 多个 数字 的 实例 
pattern. test( text) // => true: 匹配 成功 
text. search( pattern) // => 9: 首次 匹配 成功 的 位置 
text. match( pattern) // => ["1", "2", "3"]: 所有 匹配 组成 的 数组 
text. replace( pattern, "#"); // => "testing: #, #, #" 
text. split(/\ D+/); // => ["","1"," 2"," 3"]: 用 非 数字 字符 截取 字符串

```



















