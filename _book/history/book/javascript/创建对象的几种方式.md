# JavaScript: 创建对象的几种方式

- 概览
	- 一直对创建方式缺乏了解的原因
	- 几种创建对象的源码
	- 各自是为了满足什么需求，或者有什么优缺点
	- 涉及到的重要知识点

#1 

在自己之前所参与到的项目中，并不存在要模拟构架类对象，使用对象都是直接一个直接量{}满足需求，有属性添加的需求直接往上面添加。被面试问到后没能回答好，所以参考了下《JavaScript高级程序设计》发现确实还是有很多构建方法，如下做些总结。虽然有很多文章写了关于此类的文章，但阅读起来不符合自己整理思路，所以基于他人的笔记稍作修改。


#2

几种方式的代码写法（注意区分工厂模式和寄生虫模式）：

```

// 工厂模式
function people(name,age,sex){
	var o = new Object();
	o.name = name;
	o.age = age;
	o.sex = sex;
	o.speakName = function(){
		console.log(o.name);
	}
	return o;
}

//构造函数模式
function People(name,age,sex){
	this.name = name;
	this.age = age;
	this.sex = sex;
	this.speakName = function(){
		console.log(this.name);
	}
}

//原型模式
function People(){}
People.prototype = {
	constructor : People,
	name : "小明",
	age : 18,
	sex : "男",
	speakName : function(){
		console.log(this.name);
	}
}

//组合使用构造函数模式和原型模式
function People(name,age,sex){
	this.name = name;
	this.age = age;
	this.sex = sex;
	this.friends = ["小李","小王"];
}
People.prototype = {
	constructor : People,
	speakName : function(){
		console.log(thi.name);
	}
}

//动态原型模式
function People(name,age,sex){
	this.name = name;
	this.age = age;
	this.sex = sex;
	if (typeof this.speakName != 'function'){
	People.prototype.speakName = function(){
		console.log(this.name);
		}
	}
}	

//寄生构造函数模式
function People(name,age,sex){
	var o = new Object();
	o.name = name;
	o.age = age;
	o.sex = sex;
	o.speakName = function(){
		console.log(o.name);
	}
	return o;
}

//稳妥构造函数模式
function People(name,age,job){
	var o = new Object();
	//可以在这里定义私有变量和函数
	o.speakName = function(){
		console.log(name);
	};
	return o;
}

```

#3 

写法多的眼花缭乱，到底出于什么需求衍生了对应的写法，或者什么缺点使得我们要使用其他的写法。

- 工厂模式
	- 优点：解决了创建多个相似对象的问题
	- 缺点：无法解决instanceOf的对象识别问题
- 构造函数模式
	- 优点：利用了构造函数能创建特定类型对象的特性
	- 缺点：每个方法都要在实例上重新创建一遍，即两个不同对象中的speakName方法创建了多次
	- 备注：要使用构造函数模式，显式使用new操作符，这总方式实际上会执行如下四个步骤
		- 创建一个新对象
		- 将构造函数的作用域赋值给新对象
		- 执行构造函数中的代码
		- 返回新对象
	- 备注：构造函数和普通函数唯一区别就是调用方式不同
- 原型模式
	-  优点：解决了多个实例对象共享属性和方法的问题，原型是一个非常重要的概念，更详细的说明见#3-原型对象
- 组合构造函数模式和原型模式
 	- 优点：组合两家所长，私有属性通过构造函数传递，共享属性通过原型定义，这也是使用最广泛个、认同率最高的一种创建自定义类型的一种方法。
- 动态原型模式
	- 优点：为了方便其他OO语言开发者在构造函数和原型方式混用的疑惑，产生了动态原型模式。可以判定给某个方法是否存在，来确定是否在原型中初始化它。
- 寄生构造函数模式
	- 备注：跟工厂模式定义没有任何差别，唯独使用的时候是**使用new关键字**来使用的。**暂时不明所以**。
- 稳妥对象模式
	- 备注：即没有公共属性，其他对象也不引用this对象，使用时**不使用new操作符**调用构造函数。据说是适合在一些安全环境下使用，**暂时不明所以**。

#4 

- 原型对象
	1. 理解原型对象
		- 无论什么时候只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象。默认情况下，所有原型都会自动获得一个constructor属性，这个属性包含一个会系那个prototype属性所在函数的指针。即Person.prototype.constructor指向Person。
		- 当调用构造函数创建一个新实例后，该实例内部将包含一个指针，指向构造函数的原型对象。ECMA-262第5版管这个指针叫[[Prototype]]]，虽然没有标准的模式访问它，但多数浏览器都支持一个\_\_proto\_\_。要区分开的是，这个连接存在于实例和构造函数的原型对象之间，而不是存在于实例和构造函数之间。
		
		![图](/Users/tangyefei/Desktop/Screen Shot 2016-09-25 at 8.10.46 PM.png)

		- 虽然所有实现中都无法访问到\_\_proto\_\_，但我们可以通过两种方式来确认对象之间的这种关系：（1）Person.prototype.isPrototypeof(person1) === true （2）Object.getPrototypeOf(person1) === Person.prototype
		- 关于实例对象和原型之间的set和get的关系，获取属性会先从实例对象中找然后从原型对象中查找，至于设置实例对象只能在自身上操作而无法将这种操作作用在原型对象上。不再赘述。
	2. 原型与in操作符
		- 只要能通过对象访问到的，通过in操作符也能访问到；hasOwnProperty()只在属性存在于实例中才返回true。
		- 屏蔽了原型中不可枚举属性的实例属性也会被返回，因为所有开发人员定义的属性都是可以被枚举的（没有添加enumerable特性的）。**这句一直不是很理解。** [**TODO** 6.2.2需要阅读原书来理解，相关：定义了不可枚举的属性是不可以for in查看的]。
		- 要获取所有属性（包括不可枚举）	可以使用getOwnPropertyNames方法。
	3. 更简单的原型语法
		- 如果指明函数的Prototype中没有包含constructor，尽管intanceof还能返回正确的结果，但是通过constructor已经无法确定对象的类型了。
		- 可通过设置constructor: Person确保通过constructor能访问到正确的值，但这种方式会导致constructor变成可美剧的，默认情况下constructor是不可枚举的。
	4. 原型的动态性
		- 对于已经构建出来的实例对象，再修改原型对象上的属性，也会导致实例对象的属性也得到状态更新；但是如果在实例对象已经构建出以后，再重新给整个prototype赋值，是会导致这种关联断裂，即无法使实例对象上更新的。
	5. 原生/内建对象的原型
		- 原生/内建对象的原型上封装了一些方法，可以引用，对于不满足需求的方法，我们也可以直接在上面自定义方法。
	6. 原型对象的问题
		- 所有实例默认情况下都将有相同的属性值，这是最大大问题。这也是很少单独使用原型模式的原因。
	

- 参考
	- [《JavaScript高级程序设计（第3版）》](https://book.douban.com/subject/10546125/)







































